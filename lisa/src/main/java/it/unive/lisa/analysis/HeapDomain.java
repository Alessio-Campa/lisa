package it.unive.lisa.analysis;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import it.unive.lisa.symbolic.Identifier;
import it.unive.lisa.symbolic.heap.HeapExpression;
import it.unive.lisa.symbolic.heap.HeapIdentifier;

/**
 * A semantic domain that can evaluate the semantic of statements that operate
 * on heap locations, and not on concrete values. A heap domain can handle
 * instances of {@link HeapExpression}s, and manage identifiers that are
 * {@link HeapIdentifier}s.
 * 
 * @param <D> the concrete type of the {@link HeapDomain}
 * 
 * @author <a href="mailto:luca.negrini@unive.it">Luca Negrini</a>
 */
public interface HeapDomain<D extends HeapDomain<D>>
		extends SemanticDomain<D, HeapExpression, HeapIdentifier>, Lattice<D> {

	/**
	 * Yields the identifier that was computed during the generation of this heap
	 * domain, if any. If this domain was not generated by the evaluation of a
	 * {@link HeapExpression}, this method returns {@code null}.
	 * 
	 * @return the generated identifier, or {@code null} 
	 */
	Identifier getComputedIdentifier();

	/**
	 * Yields the substitution, in the form of a list of {@link Replacement}s that
	 * <b>must</b> be processed in their order of appearance, that the creation of
	 * this heap domain caused. This substitution maps {@link Identifier}s in the
	 * pre-state to {@link Identifier}s in the post state. If no substitution needs
	 * to be applied, this method should return an empty list.
	 * 
	 * @return the list of replacements
	 */
	List<Replacement> getSubstitution();

	/**
	 * A replacement between {@link Identifier}s caused by a change in the heap
	 * abstraction structure. A replacement express a relation between an identifier
	 * (returned by {@link #getId()}) and a set of identifiers (returned by
	 * {@link #getIds()}). The type of relation (thus how to handle values returned
	 * by the two aforementioned methods) depends on the instance of {@link Type}
	 * that is returned by {@link #getType()}.
	 * 
	 * @author <a href="mailto:luca.negrini@unive.it">Luca Negrini</a>
	 */
	public static final class Replacement {

		/**
		 * The type of {@link Replacement}. This can be a {@link #MATERIALIZATION} or a
		 * {@link #MERGE}.
		 * 
		 * @author <a href="mailto:luca.negrini@unive.it">Luca Negrini</a>
		 */
		public enum Type {
			/**
			 * A materialization is a replacement that materializes new nodes from an
			 * existing one, causing the removal of an identifier and the creation of a set
			 * of identifiers, that must all be mapped to the abstract value of the removed
			 * one.
			 */
			MATERIALIZATION,

			/**
			 * A merge is a replacement that merges existing nodes into a new one, causing
			 * the removal of a set of identifiers and the creation of a new identifier,
			 * that must be mapped to the least upper bound of the abstract values of the
			 * removed ones.
			 */
			MERGE
		}

		/**
		 * The single identifier that is part of the replacement
		 */
		private final Identifier id;

		/**
		 * The set of identifiers that are part of the replacement
		 */
		private final Set<Identifier> ids;

		/**
		 * The type of replacement
		 */
		private final Type type;

		/**
		 * Builds the replacement.
		 * 
		 * @param id   the {@link Identifier} that this replacement targets
		 * @param type the type of replacement
		 */
		public Replacement(Identifier id, Type type) {
			this.id = id;
			this.type = type;
			this.ids = new HashSet<>();
		}

		/**
		 * Adds an {@link Identifier} to the set of identifiers that are part of this
		 * replacement.
		 * 
		 * @param id the identifier to add
		 */
		public void addId(Identifier id) {
			if (id.equals(this.id))
				throw new IllegalArgumentException("An identifier cannot appear on both sides of a replacement");

			if (ids.contains(id))
				throw new IllegalArgumentException(
						"The given identifier has already been considered as part of the replacement");

			ids.add(id);
		}

		/**
		 * Yields the {@link Type} of this replacement.
		 * 
		 * @return the type
		 */
		public Type getType() {
			return type;
		}

		/**
		 * Yields the single identifier that is part of the replacement.
		 * 
		 * @return the identifier
		 */
		public Identifier getId() {
			return id;
		}

		/**
		 * Yields the set of identifiers that are part of the replacement.
		 * 
		 * @return the set of identifiers
		 */
		public Set<Identifier> getIds() {
			return ids;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((id == null) ? 0 : id.hashCode());
			result = prime * result + ((ids == null) ? 0 : ids.hashCode());
			result = prime * result + ((type == null) ? 0 : type.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Replacement other = (Replacement) obj;
			if (id == null) {
				if (other.id != null)
					return false;
			} else if (!id.equals(other.id))
				return false;
			if (ids == null) {
				if (other.ids != null)
					return false;
			} else if (!ids.equals(other.ids))
				return false;
			if (type != other.type)
				return false;
			return true;
		}

		@Override
		public String toString() {
			switch (type) {
			case MATERIALIZATION:
				return "{" + StringUtils.join(ids, ", ") + "} -> {" + id + "}";
			case MERGE:
				return "{" + id + "} -> {" + StringUtils.join(ids, ", ") + "}";
			default:
				return type + " [id:" + id + ", set: " + StringUtils.join(ids, ", ") + "]";
			}
		}
	}
}
