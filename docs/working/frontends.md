# Creating a frontend

To use LiSA for analyzing a program, one needs to create a _frontend_ for the language used to write the program. Below you can find an example on how to build a frontend for a dummy language _Lang_.

## Creating the project 

### From command line

Make sure you have Gradle installed on your machine and available on the `PATH` system variable. You can download Gradle from [here](https://gradle.org/install/).

1. Browse to the folder where you want to create the project. This should be an empty folder.
2. (Optional) Execute `git init` to initialize an empty git repository.
	* If you already have a remote repository, add the new remote with `git remote add <url>` and then fetching and pulling your alredy existeing files.
3. Execute `gradle init`. This will create all the files needed for starting a new Gradle project. When prompted for the interactive project configuration, select the following:
	* Select type of project to generate: **application** 
	* Select implementation language: **Java**
	* Split functionality across multiple subprojects?: **no**
	* Select build script DSL: **Groovy**
	* Select test framework: **JUnit 4**
4. Add the LiSA project as submodule: `git submodule add git@github.com:UniVE-SSV/lisa.git`	or `git submodule add https://github.com/UniVE-SSV/lisa.git`
5. Make the main project aware of LiSA:
	* in `settings.gradle`, declare the project by adding the following lines:
		```groovy
		include('lisa')
		project(':lisa').projectDir = file('lisa/lisa')
		```
	* in `app/build.gradle`, declare a dependency to the LiSA project by adding:
		```groovy
		dependencies {
			implementation project(':lisa')
			// other dependencies go here
		}
		```
		
Desktop/wow
Tweak project structure
gitignore
submodule
settings.gradle
build.gradle

### From Eclipse

Make sure you have installed the [Gradle IDE pack](https://marketplace.eclipse.org/content/gradle-ide-pack) plugin in your Ecliose installation.

1. Create a new Gradle Project: `File -> New -> Gradle Project`

## Packages
The project should have a package `cfg`, containing the class `LangToCFG.java` that handles the conversion from a program to the corresponding LiSA CFG. Then, the package is split as follows:
 - `cfg.calls`: contains specific language native calls (e.g., GoSum corresponds to the native plus (+) operation in Go);
 - `cfg.custom`: contains specific language statements (e.g., GoVariableDeclaration);
 - `cfg.literals`: contains specific language literals (e.g., GoInterger, GoString).
 
## Language to LiSA CFG
The class handling the conversion from a program to the corresponding LiSA CFG is `LangToCFG.java`. It is based on the Visitor pattern and it should extend the class `ParserBaseVisitor<Statement>`, parametric on `Statement`, generated by ANTLR.

The class constructor should take a file path to the program we aim to analyzer. For Go, for example is
```java
public GoToCFG(String filePath) {
	this.filePath = filePath;
}
```
The entry point of the classis the method `toLiSACFG` returning a `Collection` of the CFGs collected by the program at `filePath`. For example, in Go, such method is
```java
public Collection<CFG> toLiSACFG() throws IOException {
	InputStream stream;
	try {
		stream = new FileInputStream(getFilePath());
  	} catch (FileNotFoundException e) {
    System.err.println(filePath + " does not exist. Exiting.");
		return new ArrayList<>();
	}

	GoLexer lexer = new GoLexer(CharStreams.fromStream(stream, StandardCharsets.UTF_8));
	GoParser parser = new GoParser(new CommonTokenStream(lexer));
	ParseTree tree = parser.sourceFile();
	visit(tree);
	stream.close();
  
	return cfgs;
}
```
Visiting a program, we may visit either statements or expressions and the result obtained by the visit changes the meaning depending on the type of the visit. In particular:
- if an expression is visited, the result should be the parsed expression. For instance, `visitSum` visits a sum expression (`e1 + e2`) and returns the Go sum expression as result
```java
public Expression visitSum(ExpressionContext ctx) {	
  return new GoSum(currentCFG, visitExpression(ctx.expression(0)), visitExpression(ctx.expression(1)));
}
```
- if a statement is visited, the result should be its exit node. For instance, in Go , the method `visitVarDecl` visits a list of variable declarations. Each variable declaration is visited and, as results, the last variable declaration is returned.
```java
public Statement visitVarDecl(VarDeclContext ctx) {
	Statement lastStmt = null;
	for (VarSpecContext varSpec : ctx.varSpec()) {
		Statement currStmt = visitVarSpec(varSpec);
		
		if (lastStmt != null)
			currentCFG.addEdge(new SequentialEdge(lastStmt, currStmt));
		lastStmt = currStmt;
	}

	return lastStmt;
}
```

## Native calls 
Language specific native calls (e.g., sum, multiplication, logical and) should extend the LiSA class `NativeCall`. For example, the `GoSum` class above corresponds to the Go native class to sum (+)

```java
public class GoSum extends NativeCall {
	
	/**
	 * Builds a Go sum expression. The location where 
	 * this Go sum expression appears is unknown 
	 * (i.e. no source file/line/column is available).
	 * 
	 * @param cfg	the cfg that this Go sum expression belongs to
	 * @param exp1	left-hand side operand
	 * @param exp2 	right-hand side operand 
	 */
	public GoSum(CFG cfg, Expression exp1, Expression exp2) {
		super(cfg, null, -1, -1, "+", exp1, exp2);
	}
}
```

## Specific language statements 
Language specific statements that are not explicitly modeled in LiSA (e.g., variable declaration) should extend the LiSA class `Statement` (or a subclass of it, such as `Assignment`). For example, the `GoVariableDeclaration` class above models Go variable declarations.

```java
public class GoVariableDeclaration extends Assignment {

	/**
	 * Builds a Go variable declaration with initialization,
	 * assigning {@code expression} to {@code target},
	 * happening at the given location in the program.
	 * 
	 * @param cfg        the cfg that this declaration belongs to
	 * @param sourceFile the source file where this declaration happens. If unknown,
	 *                   use {@code null}
	 * @param line       the line number where this declaration happens in the source
	 *                   file. If unknown, use {@code -1}
	 * @param col        the column where this statement happens in the source file.
	 *                   If unknown, use {@code -1}
	 * @param var	     the declared variable
	 * @param expression the expression to assign to {@code var}
	 */
	public GoVariableDeclaration(CFG cfg, String sourceFile, int line, int col, Variable var, Expression expression) {
		super(cfg, sourceFile, line, col, var, expression);
	}
}
```

## LiteralsÂ 

Language specific literals (e.g., string, integer, boolean) should extend the LiSA class `Literal`. For example, the `GoString` class above models Go native strings.

```java
public class GoString extends Literal {

	/**
	 * Builds a Go string value. The location where 
	 * this Go string value appears is unknown 
	 * (i.e. no source file/line/column is available).
	 * 
	 * @param cfg	the cfg that this Go string belongs to
	 * @param value the string value
	 */
	public GoString(CFG cfg, String value) {
		super(cfg, value);
	}
}
```